#Uva, Where's Waldorf?
// Where's Waldorfv.1.cpp : Defines the entry point for the console application.
//

#include "stdafx.h"
#include <stdio.h>
#include <stdlib.h>
#include <conio.h>
#include <ctype.h>
#include <iostream>
#include <string>
#include <cctype>
#define maxLen 50
#define nOfDirections 8
//1. Just get simple input
//2. Process it
//3. And output
char ** GetCharMatrix(int n, int m) {
	char ** matrix = (char**)malloc(sizeof(char*) * n);
	for (int i = 0; i < n; i++)
	{
		matrix[i] = (char*)malloc(sizeof(char) * m);
	}
	return matrix;
}
void TEST_FILL_MATRIX(char ** matrix,int  rows,int columns,char letter) {
	
	for (int i = 0; i < rows; i++)
	{
		for (int j = 0; j < columns; j++)
		{
			matrix[i][j] = letter;
		}
	}
}
void TEST_OUTPUT(char** matrix,int n, int m) {
	for (int i = 0; i < n; i++)
	{
		for (int j = 0; j < m; j++)
		{
			printf("%c ",matrix[i][j]);
		}
		printf("\n");
	}
}
void Input(char ** matrix, int rows, int columns) {
	scanf_s("\n");
	for (int i = 0; i < rows; i++)
	{
		scanf_s("\n");
		fgets(matrix[i], columns + 1, stdin);
	}
}
char ** GetWordsForSearch(int nOfLines) {
	char ** matrix = (char**)malloc(sizeof(char*) * nOfLines);
	for (int i = 0; i < nOfLines; i++)
	{
		std::string line;
		std::cin >> line;
		matrix[i] = (char*)malloc(sizeof(char) * line.length());
		strcpy_s(matrix[i], line.length() + 1 , line.c_str());
	}
	return matrix;
}

bool Check(char** matrix,int rows, int columns, int r,int c
	,int i, int j, std::string word) {
	word[1] = tolower(word[1]);
	if ((r + i < 0 || r + i > rows )
		|| (c + j < 0 || c + j > columns))
		return false;
	matrix[r + i][c + j] = tolower(matrix[r + i][c + j]);

	return (matrix[r + i][c + j] == word[1])
		&& (
		(r - i + (word.length() - 1) * i >= 0 && r - i +( word.length() -1)* i <= rows - 1)		
			&& 
		(c - j + (word.length() -1) * j >= 0 && c  - j + (word.length() -1) * j <= columns - 1)
				
			);
}
bool StraightSearch(char** matrix, int rows, int columns, int r,int c
	, int i, int j, std::string word) {
	
	for (int q = 2; q < word.length(); q++)
	{
		r += i;
		c += j;//to lower case?

		word[q] = tolower(word[q]);
		matrix[r][c] = tolower(matrix[r][c]);

		if (word[q] != matrix[r][c])
			return false;
	}
	return true;
}
bool CheckPossiblePosition(char ** matrix,int rows, int columns
	,int rPos,int cPos, std::string word) {

	/*if (offset == word.length())
		return true;*/

	for (int i = -1; i <= 1; i++)
	{
		for (int j = -1; j <= 1; j++)
		{
			if (i == 0 && j == 0)
				continue;
			if (Check(matrix, rows, columns, rPos,cPos, i, j, word)) {
				rPos += i;
				cPos += j;
				if (StraightSearch(matrix, rows, columns, rPos,cPos, i, j, word))
					return true;
				rPos -= i;
				cPos -= j;
			}
		}
	}
	return false;
}
int* FindPosition(char ** matrix, int rows, int columns, char * word) {
	int rPos, cPos;
	int pos[2];
	for (int i = 0; i < rows; i++)
	{
		for (int j = 0; j < columns; j++)
		{
			matrix[i][j] = tolower(matrix[i][j]);
			word[0] = tolower(word[0]);
			if (matrix[i][j] == word[0]) {
				rPos = i;
				cPos = j;
				std::string w(word);
				if (CheckPossiblePosition(matrix,rows,columns,rPos,cPos,w))
				{
					pos[0] = rPos;
					pos[1] = cPos;
					return pos;
				}
			}
		}
	}
	return NULL;
}

void FindWordsPosition(char** matrix, int rows, int columns
	, char** words, int k) {

	for (int i = 0; i < k; i++)
	{
		int * pos = FindPosition(matrix, rows, columns, words[i]);
		if (pos != NULL) {
			printf("%d %d\n", pos[0] + 1, pos[1] + 1);
			pos = NULL;
		}
	}
}
int main()
{
	int nOfCases;
	scanf_s("%d", &nOfCases);
	
	printf("\n");
	for (int i = 0; i < nOfCases; i++)
	{
		//  1 <= rows,columns <= 50
		int rows, columns;
		scanf_s("%d%d", &rows, &columns);
		char** matrix = GetCharMatrix(rows, columns);
		Input(matrix,rows,columns);
		//TEST_OUTPUT(matrix, rows, columns);
		//1 <= k <= 20
		int k;
		scanf_s("%d", &k);
		char ** words= GetWordsForSearch(k);
		//TEST_OUTPUT(words, k, );
		FindWordsPosition(matrix, rows, columns, words, k);


		printf("\n");
	}
	

    return 0;
}

